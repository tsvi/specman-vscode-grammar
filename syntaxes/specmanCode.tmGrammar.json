{
  "contexts": {
    "code": [
      {
        "meta_content_scope": "meta.class.body.specman"
      },
      {
        "include": "member-declaration"
      },
      {
        "include": "priority-scopes"
      },
      {
        "include": "scalar-types"
      },
      {
        "include": "when-inheritance"
      },
      {
        "include": "scalar-type-definition"
      },
      {
        "include": "checks"
      },
      {
        "include": "constraint-def"
      },
      {
        "include": "code-blocks"
      },
      {
        "include": "methods"
      },
      {
        "include": "stray-brackets-code"
      },
      {
        "include": "default-scopes"
      }
    ],
    "actions": [
      {
        "meta_content_scope": "meta.actions.specman"
      },
      {
        "include": "priority-scopes"
      },
      {
        "include": "inline-generation"
      },
      {
        "include": "struct-allocation"
      },
      {
        "include": "variable-declaration"
      },
      {
        "include": "checks"
      },
      {
        "include": "function-calls"
      },
      {
        "include": "code-blocks"
      },
      {
        "include": "stray-brackets-actions"
      },
      {
        "include": "default-scopes"
      }
    ],
    "priority-scopes": [
      {
        "include": "literals"
      },
      {
        "include": "template-params"
      },
      {
        "include": "operators"
      },
      {
        "include": "built-in-variables"
      },
      {
        "include": "type-casting"
      },
      {
        "include": "preprocessor"
      },
      {
        "include": "built-in-function-calls"
      }
    ],
    "stray-brackets": [
      {
        "match": "\\)|\\]|\\}",
        "scope": "invalid.illegal.stray-bracket-end.specman"
      }
    ],
    "stray-brackets-code": [
      {
        "match": "\\(",
        "push": [
          {
            "meta_content_scope": "meta.class.body.specman"
          },
          {
            "match": "\\)",
            "pop": true
          },
          {
            "match": "[^\\)\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "code"
          }
        ]
      },
      {
        "match": "\\[",
        "push": [
          {
            "meta_content_scope": "meta.class.body.specman"
          },
          {
            "match": "\\]",
            "pop": true
          },
          {
            "match": "[^\\]\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "code"
          }
        ]
      },
      {
        "match": "\\{",
        "push": [
          {
            "meta_content_scope": "meta.class.body.specman"
          },
          {
            "match": "\\}",
            "pop": true
          },
          {
            "match": "[^\\}\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "code"
          }
        ]
      },
      {
        "include": "stray-brackets"
      }
    ],
    "stray-brackets-actions": [
      {
        "match": "\\(",
        "push": [
          {
            "meta_content_scope": "meta.actions.specman"
          },
          {
            "match": "\\)",
            "pop": true
          },
          {
            "match": "[^\\)\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "actions"
          }
        ]
      },
      {
        "match": "\\[",
        "push": [
          {
            "meta_content_scope": "meta.actions.specman"
          },
          {
            "match": "\\]",
            "pop": true
          },
          {
            "match": "[^\\]\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "actions"
          }
        ]
      },
      {
        "match": "\\{",
        "push": [
          {
            "meta_content_scope": "meta.actions.specman"
          },
          {
            "match": "\\}",
            "pop": true
          },
          {
            "match": "[^\\}\\n]*$(?!\\n)",
            "scope": "invalid.illegal.unbalanced-bracket.specman"
          },
          {
            "include": "actions"
          }
        ]
      },
      {
        "include": "stray-brackets"
      }
    ],
    "string": [
      {
        "meta_scope": "string.quoted.double.specman"
      },
      {
        "meta_include_prototype": false
      },
      {
        "match": "\\\\n|\\\\t|\\\\f|\\\\\"|\\\\\\\\|\\\\r",
        "scope": "constant.character.escape.specman"
      },
      {
        "match": "\"",
        "scope": "punctuation.definition.string.end.specman",
        "pop": true
      }
    ],
    "literals": [
      {
        "match": "\\b((?:\\d+)(')(?:[oO])[0-7xXzZuUlLhHwWnN]([0-7xXzZuUlLhHwWnN_]+)?)\\b",
        "captures": {
          "1": "constant.numeric.mvl.octal.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)(')(?:[dD])[0-9xXzZuUlLhHwWnN]([0-9xXzZuUlLhHwWnN_]+)?)\\b",
        "captures": {
          "1": "constant.numeric.mvl.decimal.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)(')(?:[hHxX])[0-9a-fA-FxXzZuUlLhHwWnN]([0-9a-fA-FxXzZuUlLhHwWnN_]+)?)\\b",
        "captures": {
          "1": "constant.numeric.mvl.hex.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)(')(?:[bB])[0-1xXzZuUlLhHwWnN]([0-1xXzZuUlLhHwWnN_]+)?)\\b",
        "captures": {
          "1": "constant.numeric.mvl.binary.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b(-?([0-9_]+[kKmM]?))\\b",
        "scope": "constant.numeric.unsized.integer.specman"
      },
      {
        "match": "\\b(0(?:[bB])\\s*[0-1_xXzZ?]+)\\b",
        "captures": {
          "1": "constant.numeric.unsized.binary.specman"
        }
      },
      {
        "match": "\\b(0(?:[xX])\\s*[0-9a-fA-F_xXzZ?]+)\\b",
        "captures": {
          "1": "constant.numeric.unsized.hex.specman"
        }
      },
      {
        "match": "\\b(0(?:[oO])\\s*[0-9a-fA-F_xXzZ?]+)\\b",
        "captures": {
          "1": "constant.numeric.unsized.octal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)?(')(?:[dD])\\s*[0-9_]+)\\b",
        "captures": {
          "1": "constant.numeric.sized.integer.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)?(')(?:[bB])\\s*[0-1_]+)\\b",
        "captures": {
          "1": "constant.numeric.sized.binary.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)?(')(?:[hHxX])\\s*[0-9a-fA-F_]+)\\b",
        "captures": {
          "1": "constant.numeric.sized.hex.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b((?:\\d+)?(')(?:[oO])\\s*[0-7_]+)\\b",
        "captures": {
          "1": "constant.numeric.sized.octal.specman",
          "2": "punctuation.separator.literal.specman"
        }
      },
      {
        "match": "\\b([0-9][\\.0-9_]*(?:[eE][\\+\\-]?[0-9][0-9_]*))\\b",
        "captures": {
          "1": "constant.numeric.real.specman"
        }
      },
      {
        "match": "\\b({{built_in_constants}})\\b",
        "scope": "constant.language.specman"
      },
      {
        "match": "\"",
        "scope": "punctuation.definition.string.begin.specman",
        "push": "string"
      },
      {
        "match": "0c\"[a-zA-Z]\"",
        "scope": "constant.character.literal.specman"
      }
    ],
    "operators": [
      {
        "scope": "keyword.operator.word.specman",
        "match": "\\b(and|or|not|now|in|in_table|)\\b"
      },
      {
        "scope": "keyword.operator.boolean.specman",
        "match": "(&&|\\|\\||!)"
      },
      {
        "scope": "keyword.operator.logical.specman",
        "match": "(=>)"
      },
      {
        "scope": "keyword.operator.assignment.specman",
        "match": "(=|\\+=|-=|\\*=|:=)"
      },
      {
        "scope": "keyword.operator.comparison.specman",
        "match": "(==|!=|>|<|===|!===|>=|<=)"
      },
      {
        "scope": "keyword.operator.arithmetic.specman",
        "match": "(-|\\+|\\*|/)"
      },
      {
        "scope": "keyword.operator.bitwise.specman",
        "match": "(&|\\||~|!|\\^)"
      },
      {
        "scope": "keyword.operator.width-modifier.specman",
        "match": "\\bbits\\b|\\bbytes\\b"
      },
      {
        "scope": "keyword.operator.accessor.event.specman",
        "match": "\\@"
      }
    ],
    "scalar-types": [
      {
        "match": "\\s*(?:\\b{{valid_scalar_type}})\\b",
        "captures": {
          "1": "storage.type.specman"
        }
      }
    ],
    "type-casting": [
      {
        "match": "\\.(as_a)\\s*(\\()",
        "captures": {
          "1": "keyword.other.type-casting.specman",
          "2": "punctuation.section.parens.begin.specman"
        },
        "push": [
          {
            "meta_scope": "meta.type-casting.builtin.specman"
          },
          {
            "match": "(\\()",
            "scope": "punctuation.section.parens.begin.specman",
            "push": [
              {
                "match": "(\\))",
                "scope": "punctuation.section.parens.end.specman",
                "pop": true
              },
              {
                "include": "literals"
              },
              {
                "include": "operators"
              }
            ]
          },
          {
            "match": "(\\))",
            "pop": true,
            "captures": {
              "1": "punctuation.section.parens.end.specman"
            }
          },
          {
            "match": "(?:\\b{{valid_type_no_modifier}}\\b)",
            "scope": "storage.type.specman"
          },
          {
            "include": "literals"
          },
          {
            "include": "operators"
          }
        ]
      },
      {
        "match": "\\btype\\b",
        "scope": "keyword.other.constraint.specman"
      },
      {
        "match": "(\\bis\\s+(?:\\bnot\\b)?\\s*a)(?:\\s+({{valid_determinant}}))+",
        "captures": {
          "1": "keyword.other.type-casting.specman",
          "2": "storage.type.specman"
        }
      }
    ],
    "scalar-type-definition": [
      {
        "match": "\\b(type|extend)\\b\\s+{{valid_id}}\\s*(:)\\s*{{valid_type}}(\\s*;)?",
        "captures": {
          "1": "keyword.declaration.specman",
          "2": "storage.type.specman",
          "3": "punctuation.separator.type.specman",
          "4": "storage.type.specman",
          "5": "punctuation.terminator.specman"
        }
      },
      {
        "match": "\\b(type|extend)\\b\\s+{{valid_id}}\\s*(:)\\s*(\\[\\s*)",
        "captures": {
          "1": "keyword.declaration.specman",
          "2": "storage.type.enum.specman",
          "3": "punctuation.separator.type.specman",
          "4": "punctuation.brackets.begin.specman"
        },
        "push": "enum-values-declaration"
      }
    ],
    "enum-values-declaration": [
      {
        "meta_content_scope": "meta.type.enum.specman"
      },
      {
        "match": "(\\s*,)",
        "captures": {
          "1": "punctuation.separator.specman"
        }
      },
      {
        "match": "(\\s*,)?(?:\\s*{{valid_id}}\\s*)(=\\s*)?",
        "captures": {
          "1": "punctuation.separator.specman",
          "2": "constant.other.enum.specman",
          "3": "keyword.operator.assignment.specman"
        }
      },
      {
        "match": "(\\]\\s*)(?={{scalar_width_modifier}})?",
        "captures": {
          "1": "punctuation.brackets.end.specman"
        },
        "pop": true
      },
      {
        "include": "literals"
      },
      {
        "include": "operators"
      }
    ],
    "built-in-function-calls": [
      {
        "match": "\\s+({{built_in_functions_optional_parens}})\\b(?=\\s*(\\()?)",
        "scope": "support.function.builtin.specman",
        "push": [
          {
            "meta_scope": "meta.function-call.builtin.specman"
          },
          {
            "match": "(?=\\()",
            "pop": true
          },
          {
            "match": "\\s*([;,])",
            "pop": true,
            "scope": "punctuation.terminator.specman"
          },
          {
            "include": "actions"
          }
        ]
      },
      {
        "match": "({{built_in_functions}})\\s*(\\()",
        "captures": {
          "1": "support.function.builtin.specman",
          "2": "punctuation.section.parens.begin.specman"
        },
        "push": [
          {
            "meta_scope": "meta.function-call.builtin.specman"
          },
          {
            "include": "function-call-parameters"
          }
        ]
      },
      {
        "match": "\\.({{list_pseudo_methods}}|{{built_in_member_functions}}|{{set_pseudo_methods}}|{{any_struct_member_functions}}|{{any_unit_member_functions}})\\s*(\\()",
        "captures": {
          "1": "support.function.builtin.specman",
          "2": "punctuation.section.parens.begin.specman"
        },
        "push": [
          {
            "meta_scope": "meta.function-call.builtin.specman"
          },
          {
            "include": "function-call-parameters"
          }
        ]
      },
      {
        "match": "(\\bfor\\s+each\\b)\\s*(?:\\(\\s*{{valid_id}}\\s*\\)\\s*)?(?:\\busing\\s+index\\s*\\(\\s*{{valid_id}}\\s*\\)\\s*)?(in)\\s+(?:{{valid_name}})(?=\\s*\\{)",
        "captures": {
          "1": "keyword.control.specman",
          "2": "variable.other.specman",
          "3": "variable.other.specman",
          "4": "keyword.control.specman",
          "5": "variable.other.specman"
        }
      },
      {
        "match": "(\\bfor\\s+each\\b)\\s*(?:\\(\\s*{{valid_id}}\\s*\\)\\s*)?(?:\\busing\\s+index\\s*\\(\\s*{{valid_id}}\\s*\\)\\s*)?(in)\\s+",
        "captures": {
          "1": "keyword.control.specman",
          "2": "variable.other.specman",
          "3": "variable.other.specman",
          "4": "keyword.control.specman"
        }
      }
    ],
    "function-calls": [
      {
        "match": "(?=\\b{{valid_name}}\\b\\s*\\()",
        "push": "function-consume"
      }
    ],
    "function-consume": [
      {
        "meta_scope": "meta.function-call.specman"
      },
      {
        "match": "(?!\\bis\\sa\\b)",
        "pop": true
      },
      {
        "match": "(?=\\bis\\s+\\b)",
        "pop": true
      },
      {
        "match": "\\.({{list_pseudo_methods}}|{{built_in_member_functions}}|{{set_pseudo_methods}})\\s*(\\()",
        "captures": {
          "1": "support.function.builtin.specman",
          "2": "punctuation.section.parens.begin.specman"
        },
        "set": "function-call-parameters"
      },
      {
        "match": "\\b{{valid_id}}\\b\\s*(\\()",
        "captures": {
          "1": "variable.function.specman",
          "2": "punctuation.section.parens.begin.specman"
        },
        "set": "function-call-parameters"
      }
    ],
    "function-call-parameters": [
      {
        "match": "(,)",
        "scope": "punctuation.separator.specman"
      },
      {
        "match": "(\\))\\s*(?=;)?",
        "pop": true,
        "captures": {
          "1": "punctuation.section.parens.end.specman",
          "2": "punctuation.terminator.specman"
        }
      },
      {
        "include": "actions"
      }
    ],
    "methods": [
      {
        "match": "(?=^\\s*(?:{{struct_access}})?\\s*(static\\s+)?(final\\s+)?\\s*\\b{{valid_id}}\\b\\s*\\()",
        "push": "method-declaration"
      }
    ],
    "method-declaration": [
      {
        "match": "({{struct_access}})?\\s*(static\\s+)?(final\\s+)?\\s*\\b{{valid_id}}\\b\\s*(\\()",
        "captures": {
          "1": "storage.modifier.function.specman",
          "2": "storage.modifier.function.specman",
          "3": "storage.modifier.function.specman",
          "4": "meta.method.identifier.specman entity.name.function.specman",
          "5": "meta.method.parameters.specman punctuation.section.parens.begin.specman"
        },
        "set": "method-parameters"
      },
      {
        "match": "^((?!is).)*$",
        "pop": true
      }
    ],
    "method-parameters": [
      {
        "meta_content_scope": "meta.method.parameters.specman"
      },
      {
        "match": "(?:{{valid_id}}\\s*(:)\\s*(?:(\\*)?{{valid_type}}))",
        "captures": {
          "1": "variable.parameter.specman",
          "2": "punctuation.separator.parameter.specman",
          "3": "punctuation.accessor.parameter.specman",
          "4": "storage.type.specman"
        }
      },
      {
        "match": ",",
        "scope": "punctuation.separator.parameter.specman"
      },
      {
        "match": "\\)\\s*(;)",
        "scope": "punctuation.section.parens.end.specman",
        "captures": {
          "1": "punctuation.terminator.specman"
        },
        "pop": true
      },
      {
        "match": "\\)",
        "scope": "punctuation.section.parens.end.specman",
        "set": "method-declaration-end"
      },
      {
        "include": "literals"
      },
      {
        "include": "operators"
      }
    ],
    "method-declaration-end": [
      {
        "match": "(:)\\s*{{valid_type}}",
        "captures": {
          "1": "punctuation.separator.return-type.specman",
          "2": "meta.method.return-type.specman storage.type.specman"
        }
      },
      {
        "match": "(\\@){{valid_id}}",
        "captures": {
          "1": "punctuation.accessor.event.specman",
          "2": "keyword.control.function.event.specman"
        }
      },
      {
        "match": "(is)\\s+(empty|undefined|import.*)\\s*(;)",
        "captures": {
          "1": "keyword.other.function.specman",
          "2": "keyword.modifier.function.specman",
          "3": "punctuation.terminator.specman"
        },
        "pop": true
      },
      {
        "match": "(is)\\s+(only|first|also)?",
        "captures": {
          "1": "keyword.other.function.specman",
          "2": "keyword.modifier.function.specman"
        }
      },
      {
        "match": "\\{",
        "scope": "punctuation.section.method.begin.specman",
        "set": [
          {
            "meta_content_scope": "meta.actions.specman"
          },
          {
            "match": "(\\})\\s*(;)?",
            "captures": {
              "1": "punctuation.section.method.end.specman",
              "2": "punctuation.terminator.specman"
            },
            "pop": true
          },
          {
            "include": "actions"
          }
        ]
      }
    ],
    "variable-declaration": [
      {
        "match": "\\b(var|item)\\b\\s*(?:{{valid_id}}\\s*)(:)\\s*{{valid_type}}",
        "captures": {
          "1": "keyword.declaration.specman",
          "2": "variable.other.specman",
          "3": "punctuation.separator.type.specman",
          "4": "storage.type.specman"
        }
      },
      {
        "match": "(\\bvar\\b)\\s*(?:{{valid_id}}\\s*)(:)\\s*(\\[\\s*)",
        "captures": {
          "1": "keyword.declaration.specman",
          "2": "variable.other.specman",
          "3": "punctuation.separator.type.specman",
          "4": "punctuation.brackets.begin.specman"
        },
        "push": "enum-values-declaration"
      },
      {
        "match": "(\\bvar\\b)\\s*(?:{{valid_id}}\\s*)(:=\\s*)",
        "captures": {
          "1": "keyword.declaration.specman",
          "2": "variable.other.specman",
          "3": "keyword.operator.assignment.specman"
        }
      }
    ],
    "when-inheritance": [
      {
        "match": "(?=^\\s*when(?:\\s+({{valid_determinant}}))+\\s*\\{)",
        "push": "struct-declaration"
      }
    ],
    "templates": [
      {
        "match": "(?=^\\s*(?:package\\s+)?template\\s+(?:extend\\s+)?\\b(?:struct|unit|interface|numeric_type)\\b)",
        "push": "template-declaration"
      }
    ],
    "template-declaration": [
      {
        "meta_scope": "meta.class.declaration.template.specman"
      },
      {
        "match": "(package\\s+)?(template)\\s+(extend\\s+)?\\b(struct|unit|interface)\\b\\s+(?:{{valid_id}}\\s+)\\bof\\b\\s+",
        "captures": {
          "1": "entity.name.namespace.specman",
          "2": "keyword.declaration.template.specman",
          "3": "keyword.declaration.specman",
          "4": "keyword.declaration.class.specman",
          "5": "entity.name.class.template.specman"
        },
        "pop": true
      }
    ],
    "template-params": [
      {
        "match": "(<)\\s*(?:{{valid_id}}\\s*)\\'\\s*\\b(type|exp)(\\s*>\\s*)(:\\s*)({{scalar_types}})",
        "captures": {
          "1": "punctuation.separator.specman",
          "2": "variable.parameter.template.specman",
          "3": "keyword.declaration.specman",
          "4": "punctuation.separator.specman",
          "5": "punctuation.separator.specman",
          "6": "storage.type.specman"
        }
      },
      {
        "match": "(<)\\s*(?:{{valid_id}}\\s*)\\'\\s*\\b(type|exp)(\\s*>\\s*)(?:(:\\s*)(struct|interface|object|list|scalar|numeric|custom_numeric|enum|port))?",
        "captures": {
          "1": "punctuation.separator.specman",
          "2": "variable.parameter.template.specman",
          "3": "keyword.declaration.specman",
          "4": "punctuation.separator.specman",
          "5": "punctuation.separator.specman",
          "6": "storage.type.category.specman"
        }
      },
      {
        "match": "(<)\\s*(?:{{valid_id}}\\s*)\\'\\s*\\b(?:{{valid_id}}\\s*)(>)",
        "captures": {
          "1": "punctuation.separator.specman",
          "2": "variable.parameter.template.specman",
          "3": "keyword.declaration.specman",
          "4": "punctuation.separator.specman"
        }
      }
    ],
    "member-declaration": [
      {
        "match": "({{struct_access}}\\s+)?(?:{{valid_id}}\\s*)(:)\\s*(\\blist\\s+of\\s*)?\\b(in|out|inout)\\b\\s+([a-z]+_port\\s+of)\\s",
        "captures": {
          "1": "storage.modifier.access.specman",
          "2": "variable.other.member.specman",
          "3": "punctuation.separator.type.specman",
          "4": "storage.modifier.specman",
          "5": "storage.modifier.direction.specman",
          "6": "storage.type.specman"
        }
      },
      {
        "match": "({{struct_access}}\\s+)?(static\\s+)?(const\\s+)?([!|~]\\s*)?(%\\s*)?(?:{{valid_id}}\\s*)(?:{{list_length_expr}})?(:)(?:\\s*{{valid_type_no_modifier}}\\s*)(;|=)",
        "captures": {
          "1": "storage.modifier.access.specman",
          "2": "storage.modifier.static.specman",
          "3": "storage.modifier.const.specman",
          "4": "punctuation.definition.variable.generation.specman",
          "5": "punctuation.definition.variable.physical.specman",
          "6": "variable.other.member.specman",
          "7": "punctuation.separator.type.specman",
          "8": "storage.type.specman",
          "9": "punctuation.terminator.specman"
        }
      },
      {
        "match": "({{struct_access}}\\s+)?(static\\s+)?(const\\s+)?([!|~]\\s*)?(%\\s*)?(?:{{valid_id}}\\s*)(?:{{list_length_expr}})?(:)(?:\\s*{{valid_scalar_type}}\\s*)",
        "captures": {
          "1": "storage.modifier.access.specman",
          "2": "storage.modifier.static.specman",
          "3": "storage.modifier.const.specman",
          "4": "punctuation.definition.variable.generation.specman",
          "5": "punctuation.definition.variable.physical.specman",
          "6": "variable.other.member.specman",
          "7": "punctuation.separator.type.specman",
          "8": "storage.type.specman"
        }
      },
      {
        "match": "({{struct_access}}\\s+)?(static\\s+)?(const\\s+)?([!|~]\\s*)?(%\\s*)?(?:{{valid_id}}\\s*)(:)\\s*(?:{{valid_struct_type}})(?:\\s+(\\bis\\s+instance\\b))?\\s*(;|=)",
        "captures": {
          "1": "storage.modifier.access.specman",
          "2": "storage.modifier.static.specman",
          "3": "storage.modifier.const.specman",
          "4": "punctuation.definition.variable.generation.specman",
          "5": "punctuation.definition.variable.physical.specman",
          "6": "variable.other.member.specman",
          "7": "punctuation.separator.type.specman",
          "8": "storage.type.class.specman",
          "9": "storage.modifier.specman",
          "10": "punctuation.terminator.specman"
        }
      },
      {
        "match": "({{struct_access}}\\s+)?(static\\s+)?(const\\s+)?([!~]\\s*)?(%\\s*)?(?:{{valid_id}}\\s*)(:)\\s*(\\[\\s*)",
        "captures": {
          "1": "storage.modifier.access.specman",
          "2": "storage.modifier.static.specman",
          "3": "storage.modifier.const.specman",
          "4": "punctuation.definition.variable.generation.specman",
          "5": "punctuation.definition.variable.physical.specman",
          "6": "variable.other.member.enum.specman",
          "7": "punctutation.separator.type.specman",
          "8": "punctuation.brackets.begin.specman"
        },
        "push": "enum-values-declaration"
      },
      {
        "match": "(static\\s+)?(event)\\s+(?:{{valid_id}})(?:\\s+(is)\\s+(only)*)?",
        "captures": {
          "1": "storage.modifier.static.specman",
          "2": "storage.type.specman",
          "3": "variable.other.member.event.specman",
          "4": "keyword.other.event.specman",
          "5": "keyword.modifier.event.specman"
        }
      }
    ],
    "constraint-def": [
      {
        "match": "(\\bkeep\\b)\\s+(?:\\s*{{valid_name}})\\.(reset_soft)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "variable.other.specman",
          "3": "keyword.modifier.constraint.specman"
        }
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(\\bsoft\\b)?\\s*(\\bfor\\s+each\\b)\\s*(?:\\(\\s*{{valid_id}}\\s*\\)\\s*)?(?:\\busing\\s+index\\s*\\(\\s*{{valid_id}}\\s*\\)\\s*)?(in)\\s+(?:{{valid_name}})(?=\\s*\\{)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.modifier.constraint.specman",
          "5": "keyword.control.specman",
          "6": "variable.other.specman",
          "7": "variable.other.specman",
          "8": "keyword.control.specman",
          "9": "variable.other.specman"
        }
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(all\\s+of\\b)(?=\\s*\\{)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.control.constraint.specman"
        }
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(\\bsoft\\b)?\\s*(?=.*\\s*(=>))",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.modifier.constraint.specman"
        },
        "push": "constraint-expression"
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(\\bsoft\\b)?\\s*(?:{{valid_name}}\\s*)(\\bbefore\\b)\\s*(?:{{valid_name}})(;)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.modifier.constraint.specman",
          "5": "variable.other.specman",
          "6": "keyword.other.constraint.specman",
          "7": "variable.other.specman",
          "8": "punctuation.terminator.specman"
        }
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(\\bsoft\\b)\\s*(?:{{valid_name}})\\s+(==)\\s+(\\bselect\\b)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.modifier.constraint.specman",
          "5": "variable.other.specman",
          "6": "keyword.operator.assignment.specman",
          "7": "keyword.other.constraint.specman"
        }
      },
      {
        "match": "(\\bkeep\\b)\\s+(?:{{valid_id}}\\s+(is)\\s+)?(\\bsoft\\b)?\\s*",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.constraint.specman",
          "4": "keyword.modifier.constraint.specman"
        },
        "push": "constraint-expression"
      }
    ],
    "constraint-expression": [
      {
        "meta_scope": "meta.constraint-expression.specman"
      },
      {
        "match": "(=>\\s+)(all\\s+of\\b)?(?=\\s*\\{)",
        "captures": {
          "1": "keyword.operator.logical.specman",
          "2": "keyword.control.constraint.specman"
        },
        "pop": true
      },
      {
        "include": "priority-scopes"
      },
      {
        "include": "list-literals"
      },
      {
        "match": ";",
        "scope": "punctuation.terminator.specman",
        "pop": true
      }
    ],
    "checks": [
      {
        "match": "(\\bcheck\\b)\\s+(?:{{valid_id}}\\s+)?(\\bthat\\b)?\\s+",
        "captures": {
          "1": "keyword.statement.specman",
          "2": "entity.name.label.specman",
          "3": "keyword.other.specman"
        }
      }
    ],
    "inline-generation": [
      {
        "match": "\\s+(gen)\\s+(?:{{valid_type_no_modifier}})",
        "captures": {
          "1": "keyword.other.gen.specman",
          "2": "variable.other.specman"
        },
        "push": "inline-generation-constraint"
      }
    ],
    "inline-generation-constraint": [
      {
        "meta_content_scope": "meta.constraint.specman"
      },
      {
        "match": ";",
        "scope": "punctuation.terminator.specman",
        "pop": true
      },
      {
        "match": "(\\bkeeping\\b)(\\s*\\{)",
        "captures": {
          "1": "keyword.other.constraint.specman",
          "2": "punctuation.section.constraint_block.begin.specman"
        },
        "set": [
          {
            "meta_content_scope": "meta.inline-generation.specman"
          },
          {
            "match": "(\\})\\s*(;)",
            "pop": true,
            "captures": {
              "1": "punctuation.section.constraint_block.end.specman",
              "2": "punctuation.terminator.specman"
            }
          },
          {
            "include": "code"
          }
        ]
      }
    ],
    "struct-allocation": [
      {
        "match": "\\bnew\\b",
        "scope": "meta.function-call.new.specman keyword.other.new.specman"
      }
    ],
    "built-in-variables": [
      {
        "match": "\\b({{built_in_variables}})\\b",
        "captures": {
          "1": "variable.language.specman"
        }
      }
    ],
    "code-blocks": [
      {
        "match": "(\\bon\\b)\\s*{{valid_name}}\\s*(\\{)",
        "captures": {
          "1": "keyword.control.specman",
          "2": "variable.other.specman",
          "3": "punctuation.section.block.begin.specman"
        },
        "push": [
          {
            "meta_content_scope": "meta.code_block.specman"
          },
          {
            "match": "(\\})\\s*(;)?",
            "captures": {
              "1": "punctuation.section.block.end.specman",
              "2": "punctuation.terminator.specman"
            },
            "pop": true
          },
          {
            "include": "actions"
          }
        ]
      },
      {
        "match": "(\\b{{concurrency_actions}}\\b)?\\s*\\{",
        "captures": {
          "1": "keyword.control.specman"
        },
        "scope": "punctuation.section.block.begin.specman",
        "push": [
          {
            "meta_content_scope": "meta.code_block.specman"
          },
          {
            "match": "(\\})\\s*(;)?",
            "captures": {
              "1": "punctuation.section.block.end.specman",
              "2": "punctuation.terminator.specman"
            },
            "pop": true
          },
          {
            "include": "actions"
          }
        ]
      }
    ],
    "list-literals": [
      {
        "match": "(\\{)",
        "captures": {
          "1": "punctuation.section.list-literal.begin.specman"
        },
        "push": [
          {
            "meta_content_scope": "meta.list-literal.specman"
          },
          {
            "include": "priority-scopes"
          },
          {
            "include": "list-literals"
          },
          {
            "match": "(;)",
            "scope": "punctuation.separator.specman"
          },
          {
            "match": "(\\})\\s*",
            "captures": {
              "1": "punctuation.section.list-literal.end.specman"
            },
            "pop": true
          }
        ]
      }
    ],
    "preprocessor": [
      {
        "match": "\\s*(?:\\}\\s*)?(#\\s*(?:ifdef|ifndef|else))\\s*((?:`)?{{valid_id}})?(\\s+then\\b)?\\s*(\\{)",
        "captures": {
          "1": "keyword.control.import.specman",
          "2": "variable.other.define.specman",
          "4": "keyword.control.import.specman",
          "5": "punctuation.section.block.begin.specman"
        },
        "push": [
          {
            "meta_scope": "meta.preprocessor.specman"
          },
          {
            "match": "\\}",
            "scope": "punctuation.section.block.end.specman",
            "pop": true
          },
          {
            "include": "imports"
          },
          {
            "include": "structs"
          },
          {
            "include": "code"
          }
        ]
      },
      {
        "match": "(\\bmethod_type\\b)\\s+\\b{{valid_id}}\\b\\s*(?=\\()",
        "captures": {
          "1": "meta.function.method_type.specman keyword.declaration.specman",
          "2": "meta.function.method_type.specman entity.name.function.specman"
        }
      },
      {
        "match": "(#\\s*(?:undef))\\s*((?:`)?{{valid_id}})",
        "captures": {
          "1": "keyword.control.import.specman",
          "2": "variable.other.define.specman"
        }
      }
    ],
    "default-scopes": [
      {
        "scope": "keyword.other.specman",
        "match": "\\b(soft|compute|new)\\b"
      },
      {
        "scope": "keyword.other.statement.specman",
        "match": "\\b(keep|export|extend|template|on|expect|routine|specman|radix|ignore|illegal|traceable|untraceable|cover|using|count_only|trace_only|at_least|transition|item|ranges|cross|text|call|task|within)\\b"
      },
      {
        "scope": "support.function.builtin.specman meta.function-call.builtin.specman",
        "match": "\\b(initialize|delayed|exit|finish|post_generate|pre_generate|wave_setup|setup|setup_test|finalize|finalize_test|extract_test|run_test|get_timescale|is_gui|print_stack_trace|simulator_exists|simulator_save|sn_plusargs_exists|sn_plusarg_value|pre_save|pre_restore|post_restore|remap_tick_access|set_config|lock|unlock|release|swap|value|stop_run|get_config|get_indices|exec)\\b"
      },
      {
        "scope": "keyword.control.specman",
        "match": "\\b(until|repeat|while|for|from|to|step|each|do|break|continue|before|next|always|in|return|keeping)\\b"
      },
      {
        "scope": "keyword.other.packing.specman",
        "match": "\\b(packing|low|high|network)\\b"
      },
      {
        "scope": "keyword.conditional.specman",
        "match": "\\b(choose|matches|if|then|else|try|case|casex|casez|default)\\b"
      },
      {
        "scope": "keyword.other.temporal.specman",
        "match": "\\b(cycle|sample|event|forever|wait|change|negedge|rise|fall|delay|sync|sim|true|detach|eventually|emit)\\b"
      },
      {
        "scope": "keyword.other.define.specman",
        "match": "\\b(define|as|computed|verilog|vhdl|variable)\\b"
      },
      {
        "scope": "keyword.other.singleton.specman",
        "match": "\\b({{singletons}})\\b"
      },
      {
        "scope": "keyword.other.file.specman",
        "match": "\\b(files|load|ntv|source_ref|script|read|write)\\b"
      },
      {
        "scope": "keyword.other.fsm.specman",
        "match": "\\b(initial|idle|others|posedge|clock|cycles)\\b"
      },
      {
        "scope": "storage.modifier.specman",
        "match": "\\b(is\\s+instance|list\\s+of|attribute|::)\\b"
      },
      {
        "scope": "keyword.declaration.specman",
        "match": "\\b(DPI-C|like|implementing|conditions|created_driver|created_kind|testflow|uvm_build_config|import_python)\\b"
      },
      {
        "scope": "punctuation.terminator.specman",
        "match": "\\s*;"
      }
    ]
  }
}